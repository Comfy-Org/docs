---
title: "多语言支持"
description: "如何为自定义节点添加多语言支持"
---

import SupportedLanguages from '/snippets/zh/interface/supported languages.mdx'

如果你想要为你的多语言添加支持，可参考本篇文档了解如何添加多语言支持,

<SupportedLanguages />

## 目录结构

在你的自定义节点下创建 `locales` 文件夹，支持多种翻译文件类型：

```bash
your_custom_node/
├── __init__.py
├── your_node.py
├── js/                         # JavaScript 扩展（如有）
│   └── extension.js
└── locales/                    # 国际化文件夹
    ├── en/                     # 英语翻译（推荐作为基准）
    │   ├── nodeDefs.json      # 必需：节点定义翻译
    │   ├── main.json          # 可选：通用内容翻译
    │   ├── settings.json      # 可选：设置界面翻译
    │   └── commands.json      # 可选：命令翻译
    ├── zh/                     # 中文简体
    │   ├── nodeDefs.json
    │   ├── main.json
    │   ├── settings.json
    │   └── commands.json
    ├── zh-TW/                  # 中文繁体

```

**文件说明**：
- `main.json` - **基础文件**：扩展的主要翻译内容，包括菜单、设置分类等
- `nodeDefs.json` - **核心文件**：节点界面翻译（节点名称、输入输出参数）
- `commands.json` - **可选**：自定义命令翻译
- `settings.json` - **可选**：JavaScript 扩展设置翻译

> **重要**：`nodeDefs.json` 是最常用的翻译文件，用于翻译节点在 ComfyUI 界面中的显示。其他文件会自动合并到翻译系统中。

## 翻译文件格式详解

ComfyUI 的翻译系统基于 `main.json` 为基础，其他文件会自动合并进来。根据后端实现（`custom_node_manager.py`），翻译加载流程如下：

1. 首先加载 `main.json` 作为基础翻译
2. 然后加载并合并 `nodeDefs.json`、`commands.json`、`settings.json`
3. 最终形成完整的翻译数据结构

## nodeDefs.json - 节点定义翻译

用于翻译节点的显示名称、描述、输入输出参数等：

```json
{
  "节点类名": {
    "display_name": "节点显示名称",
    "description": "节点描述（可选）",
    "inputs": {
      "参数名": {
        "name": "参数显示名称",
        "tooltip": "参数提示（可选）"
      }
    },
    "outputs": {
      "输出名": {
        "name": "输出显示名称"
      }
    }
  }
}
```

**完整示例**（基于我们的演示节点）：

```json
{
  "I18nTextProcessor": {
    "display_name": "国际化文本处理器",
    "description": "一个简单的国际化演示节点，展示支持国际化的文本处理功能",
    "inputs": {
      "text": {
        "name": "文本输入",
        "tooltip": "要处理的原始文本内容"
      },
      "operation": {
        "name": "操作类型",
        "tooltip": "选择要执行的文本处理操作"
      },
      "count": {
        "name": "重复次数",
        "tooltip": "操作重复执行的次数"
      },
      "prefix": {
        "name": "前缀文本",
        "tooltip": "添加到文本前面的前缀内容"
      }
    },
    "outputs": {
      "processed_text": {
        "name": "处理后文本",
        "tooltip": "经过处理的最终文本结果"
      }
    }
  }
}
```

### 翻译键的对应关系

节点翻译的工作原理：

1. **节点类名**：必须与 Python 代码中 `NODE_CLASS_MAPPINGS` 的键完全一致
2. **输入参数名**：对应 `INPUT_TYPES` 中定义的参数名
3. **输出参数名**：对应 `RETURN_NAMES` 中定义的名称（如果有），否则使用索引 `"0"`、`"1"` 等

### 实际示例解析

以我们演示项目中的 `I18nTextProcessor` 节点为例：

**Python 节点定义**：
```python
class I18nTextProcessor:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "text": ("STRING", {"multiline": True, "default": "Hello World!"}),
                "operation": (["uppercase", "lowercase", "reverse", "add_prefix"], {"default": "uppercase"}),
                "count": ("INT", {"default": 1, "min": 1, "max": 10, "step": 1}),
            },
            "optional": {
                "prefix": ("STRING", {"default": "[I18N] ", "multiline": False}),
            }
        }
    
    RETURN_TYPES = ("STRING",)
    RETURN_NAMES = ("processed_text",)

NODE_CLASS_MAPPINGS = {
    "I18nTextProcessor": I18nTextProcessor,  # 这个键是翻译文件中的节点类名
}
```

**对应的翻译文件**：
```json
{
  "I18nTextProcessor": {
    "display_name": "国际化文本处理器",
    "description": "一个简单的国际化演示节点，展示支持国际化的文本处理功能",
    "inputs": {
      "text": {
        "name": "文本输入",
        "tooltip": "要处理的原始文本内容"
      },
      "operation": {
        "name": "操作类型",
        "tooltip": "选择要执行的文本处理操作"
      },
      "count": {
        "name": "重复次数",
        "tooltip": "操作重复执行的次数"
      },
      "prefix": {
        "name": "前缀文本",
        "tooltip": "添加到文本前面的前缀内容"
      }
    },
    "outputs": {
      "processed_text": {
        "name": "处理后文本",
        "tooltip": "经过处理的最终文本结果"
      }
    }
  }
}
```

### 翻译效果

有了上述翻译文件，节点在界面中的显示效果：
- **节点菜单**：显示为 "国际化文本处理器" 而不是 "I18nTextProcessor"
- **节点标题**：画布上的节点显示为 "国际化文本处理器"
- **输入参数**：`text` → "文本输入"，`operation` → "操作类型"
- **输出参数**：`processed_text` → "处理后文本"

## 实施步骤

### 步骤 1：创建目录结构

在你的自定义节点根目录下创建 `locales` 文件夹：

```bash
your_custom_node/
├── __init__.py
├── your_node.py
└── locales/
    ├── en/                     # 英语（推荐作为默认语言）
    │   └── nodeDefs.json      # 必需：节点定义翻译
    └── zh/                     # 中文
        └── nodeDefs.json      # 必需：节点定义翻译
```

### 步骤 2：确定节点类名

找到你的 Python 节点类定义，记住类名：

```python
class MyAwesomeNode:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image": ("IMAGE",),
                "strength": ("FLOAT", {"default": 1.0, "min": 0.0, "max": 2.0})
            }
        }
    
    RETURN_TYPES = ("IMAGE",)
    FUNCTION = "process"
    CATEGORY = "My Custom Nodes"

NODE_CLASS_MAPPINGS = {
    "MyAwesomeNode": MyAwesomeNode  # 这里的键就是翻译中要用的节点类名
}
```

### 步骤 3：创建 nodeDefs.json

基于你的节点定义创建翻译文件。以我们的演示节点为例：

**英文版本（`locales/en/nodeDefs.json`）**：
```json
{
  "I18nTextProcessor": {
    "display_name": "I18n Text Processor",
    "description": "A simple i18n demo node that demonstrates text processing with internationalization support",
    "inputs": {
      "text": {
        "name": "Text Input",
        "tooltip": "The original text content to be processed"
      },
      "operation": {
        "name": "Operation",
        "tooltip": "Select the text processing operation to execute"
      },
      "count": {
        "name": "Count",
        "tooltip": "Number of times to repeat the operation"
      },
      "prefix": {
        "name": "Prefix",
        "tooltip": "Prefix content to add before the text"
      }
    },
    "outputs": {
      "processed_text": {
        "name": "Processed Text",
        "tooltip": "The final processed text result"
      }
    }
  }
}
```

**中文版本（`locales/zh/nodeDefs.json`）**：
```json
{
  "I18nTextProcessor": {
    "display_name": "国际化文本处理器",
    "description": "一个简单的国际化演示节点，展示支持国际化的文本处理功能",
    "inputs": {
      "text": {
        "name": "文本输入",
        "tooltip": "要处理的原始文本内容"
      },
      "operation": {
        "name": "操作类型",
        "tooltip": "选择要执行的文本处理操作"
      },
      "count": {
        "name": "重复次数",
        "tooltip": "操作重复执行的次数"
      },
      "prefix": {
        "name": "前缀文本",
        "tooltip": "添加到文本前面的前缀内容"
      }
    },
    "outputs": {
      "processed_text": {
        "name": "处理后文本",
        "tooltip": "经过处理的最终文本结果"
      }
    }
  }
}
```

### 步骤 4：测试翻译效果

1. 重启 ComfyUI 服务器
2. 在界面中切换语言：设置 → Comfy → Language  
3. 检查节点菜单中的节点名称是否已翻译
4. 拖拽节点到画布，检查输入输出参数名称
5. **调试方法**：访问 `http://localhost:8188/i18n` 查看合并后的翻译数据

### 步骤 5：验证翻译合并

根据 `custom_node_manager.py` 的实现，可以通过以下方式验证翻译是否正确加载：

```javascript
// 在浏览器控制台中执行
fetch('/i18n')
  .then(response => response.json())
  .then(data => {
    console.log('所有翻译数据:', data);
    console.log('中文翻译:', data.zh);
    console.log('你的扩展翻译:', data.zh?.your_extension_name);
  });
```

## 高级技巧

### 翻译组合框选项

如果你的节点有下拉选项，也可以翻译选项值：

```python
# Python 节点定义
INPUT_TYPES = {
    "required": {
        "operation": (["uppercase", "lowercase", "reverse", "add_prefix"], {"default": "uppercase"})
    }
}
```

```json
{
  "I18nTextProcessor": {
    "inputs": {
      "operation": {
        "name": "操作类型",
        "tooltip": "选择要执行的文本处理操作",
        "options": {
          "uppercase": "转大写",
          "lowercase": "转小写", 
          "reverse": "反转文本",
          "add_prefix": "添加前缀"
        }
      }
    }
  }
}
```

### 处理输出名称

如果你的节点定义了 `RETURN_NAMES`，使用这些名称作为翻译键：

```python
RETURN_TYPES = ("STRING", "INT")
RETURN_NAMES = ("processed_text", "character_count")
```

```json
{
  "YourNode": {
    "outputs": {
      "processed_text": {"name": "处理后文本"},
      "character_count": {"name": "字符数量"}
    }
  }
}
```

如果没有定义 `RETURN_NAMES`，则使用索引：

```json
{
  "YourNode": {
    "outputs": {
      "0": {"name": "第一个输出"},
      "1": {"name": "第二个输出"}
    }
  }
}
```

## main.json - 菜单和设置国际化

除了节点定义，`main.json` 还可以包含菜单、设置分类和其他 UI 元素的翻译。基于 ComfyUI 前端扩展的实现，主要包括以下结构：

### 设置分类翻译

当你的 JavaScript 扩展包含设置项时，可以为设置分类提供翻译：

```json
{
  "settingsCategories": {
    "MyCustomNode": "我的自定义节点",
    "VueBasic": "Vue 基础示例",
    "AdvancedFeatures": "高级功能"
  }
}
```

### 设置项翻译

为具体的设置项提供名称和提示信息的翻译：

```json
{
  "settings": {
    "MyCustomNode_ExampleSetting": {
      "name": "示例设置",
      "tooltip": "这是一个示例设置的提示说明"
    },
    "MyCustomNode_EnableAdvanced": {
      "name": "启用高级模式",
      "tooltip": "开启高级功能，可能需要更多系统资源"
    }
  }
}
```

### 完整的 main.json 示例

结合菜单、设置和其他 UI 元素的完整示例：

```json
{
  "customNodeName": "自定义节点名称",
  "buttons": {
    "apply": "应用",
    "cancel": "取消",
    "reset": "重置",
    "export": "导出",
    "import": "导入"
  },
  "messages": {
    "success": "操作成功",
    "error": "操作失败",
    "processing": "处理中...",
    "saved": "已保存",
    "loaded": "已加载"
  },
  "settingsCategories": {
    "MyCustomNode": "我的自定义节点",
    "Performance": "性能设置",
    "Display": "显示选项"
  },
  "settings": {
    "MyCustomNode_ExampleSetting": {
      "name": "示例设置",
      "tooltip": "这是一个示例设置的提示说明"
    },
    "MyCustomNode_QualityLevel": {
      "name": "质量等级",
      "tooltip": "设置处理质量，较高质量需要更多计算时间"
    },
    "MyCustomNode_EnableDebug": {
      "name": "启用调试模式",
      "tooltip": "开启调试信息输出，用于问题排查"
    }
  },
  "menus": {
    "tools": "工具",
    "settings": "设置",
    "help": "帮助"
  }
}
```

### JavaScript 扩展中的设置定义

在你的 JavaScript 扩展中，设置的定义应该与翻译文件对应：

```javascript
// main.ts 或 extension.js
import { app } from "/scripts/app.js";

app.registerExtension({
  name: "MyCustomNode.Settings",
  async setup() {
    // 注册设置项
    app.ui.settings.addSetting({
      id: "MyCustomNode_ExampleSetting",
      category: ["MyCustomNode"], // 对应 settingsCategories 中的键
      name: "Example Setting",     // 可被翻译覆盖
      tooltip: "This is an example setting", // 可被翻译覆盖
      type: "boolean",
      defaultValue: false,
      experimental: true
    });

    app.ui.settings.addSetting({
      id: "MyCustomNode_QualityLevel",
      category: ["MyCustomNode"],
      name: "Quality Level",
      tooltip: "Set processing quality",
      type: "combo",
      options: ["Low", "Medium", "High", "Ultra"],
      defaultValue: "Medium"
    });
  }
});
```

### 翻译文件组织建议

- 每个语言文件夹的结构应该相同
- JSON 文件的键结构应该一致
- 建议先完成英文翻译作为基准
- 使用有意义的节点类名，避免过于简单的名称
- 设置 ID 建议使用 `NodeName_SettingName` 格式，便于管理

## 常见问题

### Q: 翻译不生效怎么办？

1. 检查文件路径和命名是否正确
2. 确认 JSON 语法是否有效
3. 重启 ComfyUI 服务器
4. 检查节点类名是否与 `NODE_CLASS_MAPPINGS` 一致

### Q: 如何调试翻译问题？

1. **检查 API 数据**：访问 `http://localhost:8188/i18n` 查看所有翻译数据
2. **验证文件加载**：确认你的 `locales` 文件夹路径正确
3. **检查节点类名**：确保翻译文件中的键与 `NODE_CLASS_MAPPINGS` 完全一致
4. **检查合并结果**：在 API 数据中应该能看到：
   ```json
   {
     "zh": {
       "nodeDefs": {
         "YourNodeClassName": {
           "display_name": "你的节点中文名"
         }
       }
     }
   }
   ```

### Q: 节点名称没有翻译怎么办？

1. **检查节点类名**：确保 JSON 中的键与 Python 代码中的 `NODE_CLASS_MAPPINGS` 键完全匹配
2. **重启服务器**：修改翻译文件后需要重启 ComfyUI
3. **清除缓存**：有时需要清除浏览器缓存或重新加载页面
4. **检查 JSON 语法**：使用 JSON 验证工具确保文件格式正确

## 参考示例

下面是一些对多语言支持较为完善的自定义节点示例

- [ComfyUI-IC-Light-Native](https://github.com/huchenlei/ComfyUI-IC-Light-Native/)
- [ComfyUI_LayerStyle](https://github.com/chflame163/ComfyUI_LayerStyle/tree/main)
- [](https://github.com/Mikubill/ComfyUI_ControlNet_Native)
