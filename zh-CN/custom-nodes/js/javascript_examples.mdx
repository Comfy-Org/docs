---
title: "å¸¦æ³¨é‡Šçš„ç¤ºä¾‹"
---

ä¸æ–­å¢žé•¿çš„ç¤ºä¾‹ä»£ç ç‰‡æ®µé›†åˆâ€¦â€¦

## å³é”®èœå•

### èƒŒæ™¯èœå•

ä¸»èƒŒæ™¯èœå•ï¼ˆåœ¨ç”»å¸ƒä¸Šå³é”®ï¼‰æ˜¯é€šè¿‡è°ƒç”¨ `LGraph.getCanvasMenuOptions` ç”Ÿæˆçš„ã€‚æ·»åŠ è‡ªå®šä¹‰èœå•é€‰é¡¹çš„ä¸€ç§æ–¹å¼æ˜¯åŠ«æŒè¿™ä¸ªè°ƒç”¨ï¼š

```Javascript
/* åœ¨ setup() ä¸­ */
    const original_getCanvasMenuOptions = LGraphCanvas.prototype.getCanvasMenuOptions;
    LGraphCanvas.prototype.getCanvasMenuOptions = function () {
        // èŽ·å–åŸºç¡€é€‰é¡¹
        const options = original_getCanvasMenuOptions.apply(this, arguments);
        options.push(null); // æ’å…¥åˆ†éš”çº¿
        options.push({
            content: "èœå•çš„æ–‡æœ¬",
            callback: async () => {
                // æ‰§è¡Œä»»æ„æ“ä½œ
            }
        })
        return options;
    }
```

### èŠ‚ç‚¹èœå•

å½“ä½ åœ¨èŠ‚ç‚¹ä¸Šå³é”®æ—¶ï¼Œèœå•åŒæ ·æ˜¯é€šè¿‡ `node.getExtraMenuOptions` ç”Ÿæˆçš„ã€‚ä½†è¿™æ¬¡ä¸æ˜¯è¿”å›žä¸€ä¸ª options å¯¹è±¡ï¼Œè€Œæ˜¯å°†å…¶ä½œä¸ºå‚æ•°ä¼ å…¥â€¦â€¦

```javascript
/* åœ¨ beforeRegisterNodeDef() ä¸­ */
if (nodeType?.comfyClass=="MyNodeClass") { 
    const original_getExtraMenuOptions = nodeType.prototype.getExtraMenuOptions;
    nodeType.prototype.getExtraMenuOptions = function(_, options) {
        original_getExtraMenuOptions?.apply(this, arguments);
        options.push({
            content: "åšç‚¹æœ‰è¶£çš„äº‹",
            callback: async () => {
                // æœ‰è¶£çš„æ“ä½œ
            }
        })
    }   
}
```

### å­èœå•

å¦‚æžœä½ æƒ³è¦å­èœå•ï¼Œå¯ä»¥æä¾›ä¸€ä¸ªå›žè°ƒï¼Œä½¿ç”¨ `LiteGraph.ContextMenu` åˆ›å»ºå®ƒï¼š

```javascript
function make_submenu(value, options, e, menu, node) {
    const submenu = new LiteGraph.ContextMenu(
        ["é€‰é¡¹ 1", "é€‰é¡¹ 2", "é€‰é¡¹ 3"],
        { 
            event: e, 
            callback: function (v) { 
                // ç”¨ v (=="é€‰é¡¹ x") åšç‚¹ä»€ä¹ˆ
            }, 
            parentMenu: menu, 
            node:node
        }
    )
}

/* ... */
    options.push(
        {
            content: "å¸¦é€‰é¡¹çš„èœå•",
            has_submenu: true,
            callback: make_submenu,
        }
    )
```

## æ•èŽ· UI äº‹ä»¶

è¿™å’Œä½ é¢„æœŸçš„ä¸€æ ·â€”â€”åœ¨ DOM ä¸­æ‰¾åˆ° UI å…ƒç´ å¹¶æ·»åŠ  eventListenerã€‚`setup()` æ˜¯åšè¿™ä»¶äº‹çš„å¥½åœ°æ–¹ï¼Œå› ä¸ºæ­¤æ—¶é¡µé¢å·²å®Œå…¨åŠ è½½ã€‚ä¾‹å¦‚ï¼Œæ£€æµ‹"é˜Ÿåˆ—"æŒ‰é’®çš„ç‚¹å‡»ï¼š

```Javascript
function queue_button_pressed() { console.log("é˜Ÿåˆ—æŒ‰é’®è¢«æŒ‰ä¸‹ï¼") }
document.getElementById("queue-button").addEventListener("click", queue_button_pressed);
```

## æ£€æµ‹å·¥ä½œæµå¼€å§‹

è¿™æ˜¯ä¼—å¤š `api` äº‹ä»¶ä¹‹ä¸€ï¼š

```javascript
import { api } from "../../scripts/api.js";
/* åœ¨ setup() ä¸­ */
    function on_execution_start() { 
        /* æ‰§è¡Œä»»æ„æ“ä½œ */
    }
    api.addEventListener("execution_start", on_execution_start);
```

## æ£€æµ‹å·¥ä½œæµè¢«ä¸­æ–­

è¿™æ˜¯ä¸€ä¸ªåŠ«æŒ api çš„ç®€å•ä¾‹å­ï¼š

```Javascript
import { api } from "../../scripts/api.js";
/* åœ¨ setup() ä¸­ */
    const original_api_interrupt = api.interrupt;
    api.interrupt = function () {
        /* åœ¨è°ƒç”¨åŽŸæ–¹æ³•å‰åšç‚¹ä»€ä¹ˆ */
        original_api_interrupt.apply(this, arguments);
        /* æˆ–è€…åœ¨ä¹‹åŽ */
    }
```

## æ•èŽ·èŠ‚ç‚¹ç‚¹å‡»

`node` æœ‰ä¸€ä¸ª mouseDown æ–¹æ³•å¯ä»¥è¢«åŠ«æŒã€‚
è¿™æ¬¡æˆ‘ä»¬æ³¨æ„ä¼ é€’ä»»ä½•è¿”å›žå€¼ã€‚

```javascript
async nodeCreated(node) {
    if (node?.comfyClass === "My Node Name") {
        const original_onMouseDown = node.onMouseDown;
        node.onMouseDown = function( e, pos, canvas ) {
            alert("å“Žå‘¦ï¼");
            return original_onMouseDown?.apply(this, arguments);
        }        
    }
}
```

## è‡ªå®šä¹‰å°éƒ¨ä»¶

### åˆ›å»ºæ»‘å—å°éƒ¨ä»¶

```javascript
app.registerExtension({
    name: "my.custom.slider",
    async getCustomWidgets() {
        return {
            CUSTOM_SLIDER(node, inputName, inputData, app) {
                const widget = node.addWidget("slider", inputName, inputData[1]?.default || 0, (value) => {
                    // å°éƒ¨ä»¶å€¼å˜åŒ–æ—¶çš„å›žè°ƒ
                    console.log(`${inputName} changed to: ${value}`);
                }, {
                    min: inputData[1]?.min || 0,
                    max: inputData[1]?.max || 100,
                    step: inputData[1]?.step || 1
                });
                
                return { widget };
            }
        };
    }
});
```

### åˆ›å»ºæ–‡ä»¶ä¸Šä¼ å°éƒ¨ä»¶

```javascript
app.registerExtension({
    name: "my.file.upload",
    async getCustomWidgets() {
        return {
            FILE_UPLOAD(node, inputName, inputData, app) {
                const fileInput = document.createElement("input");
                fileInput.type = "file";
                fileInput.accept = inputData[1]?.accept || "*/*";
                
                fileInput.addEventListener("change", (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
                        const formData = new FormData();
                        formData.append("file", file);
                        
                        fetch("/upload", {
                            method: "POST",
                            body: formData
                        }).then(response => response.json())
                          .then(data => {
                              console.log("File uploaded:", data);
                              // æ›´æ–°èŠ‚ç‚¹çŠ¶æ€
                          });
                    }
                });
                
                const widget = node.addDOMWidget(inputName, "file", fileInput);
                return { widget };
            }
        };
    }
});
```

## èŠ‚ç‚¹é€šä¿¡

### æœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯æ¶ˆæ¯

```javascript
import { api } from "../../scripts/api.js";

app.registerExtension({
    name: "my.server.communication",
    async setup() {
        // ç›‘å¬æ¥è‡ªæœåŠ¡å™¨çš„è‡ªå®šä¹‰æ¶ˆæ¯
        api.addEventListener("my_custom_event", (event) => {
            const data = event.detail;
            console.log("Received from server:", data);
            
            // æ ¹æ®æ¶ˆæ¯æ›´æ–° UI
            if (data.type === "progress") {
                updateProgressBar(data.progress);
            } else if (data.type === "error") {
                showErrorMessage(data.message);
            }
        });
    }
});

function updateProgressBar(progress) {
    // æ›´æ–°è¿›åº¦æ¡æ˜¾ç¤º
    const progressBar = document.getElementById("my-progress-bar");
    if (progressBar) {
        progressBar.style.width = `${progress}%`;
    }
}

function showErrorMessage(message) {
    // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
    alert(`Error: ${message}`);
}
```

### å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨æ¶ˆæ¯

```javascript
import { api } from "../../scripts/api.js";

// å‘é€è‡ªå®šä¹‰æ¶ˆæ¯åˆ°æœåŠ¡å™¨
function sendCustomMessage(nodeId, messageType, data) {
    api.fetchApi("/custom_message", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            node_id: nodeId,
            message_type: messageType,
            data: data
        })
    }).then(response => response.json())
      .then(result => {
          console.log("Server response:", result);
      })
      .catch(error => {
          console.error("Error sending message:", error);
      });
}
```

## é«˜çº§ UI å®šåˆ¶

### è‡ªå®šä¹‰èŠ‚ç‚¹å¤–è§‚

```javascript
app.registerExtension({
    name: "my.custom.appearance",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeType.comfyClass === "MySpecialNode") {
            // è‡ªå®šä¹‰èŠ‚ç‚¹é¢œè‰²
            nodeType.prototype.bgcolor = "#2a2a2a";
            nodeType.prototype.color = "#ffffff";
            
            // è‡ªå®šä¹‰ç»˜åˆ¶æ–¹æ³•
            const originalOnDrawBackground = nodeType.prototype.onDrawBackground;
            nodeType.prototype.onDrawBackground = function(ctx, canvas) {
                // è°ƒç”¨åŽŸå§‹ç»˜åˆ¶æ–¹æ³•
                originalOnDrawBackground?.apply(this, arguments);
                
                // æ·»åŠ è‡ªå®šä¹‰ç»˜åˆ¶
                ctx.fillStyle = "#ff6b6b";
                ctx.fillRect(this.pos[0] - 5, this.pos[1] - 5, 10, 10);
            };
            
            // è‡ªå®šä¹‰æ ‡é¢˜
            const originalGetTitle = nodeType.prototype.getTitle;
            nodeType.prototype.getTitle = function() {
                const originalTitle = originalGetTitle?.apply(this, arguments) || this.title;
                return `ðŸŒŸ ${originalTitle}`;
            };
        }
    }
});
```

### åŠ¨æ€æ›´æ–°èŠ‚ç‚¹è¾“å…¥

```javascript
app.registerExtension({
    name: "my.dynamic.inputs",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeType.comfyClass === "DynamicInputNode") {
            const originalOnConnectionsChange = nodeType.prototype.onConnectionsChange;
            nodeType.prototype.onConnectionsChange = function(side, slot, connect, link_info, output) {
                const result = originalOnConnectionsChange?.apply(this, arguments);
                
                if (side === 1 && connect) { // è¾“å…¥è¿žæŽ¥
                    // æ ¹æ®è¿žæŽ¥çš„è¾“å‡ºç±»åž‹åŠ¨æ€æ·»åŠ è¾“å…¥
                    const outputType = link_info.type;
                    if (outputType === "IMAGE" && !this.inputs.find(input => input.name === "mask")) {
                        this.addInput("mask", "MASK");
                    }
                }
                
                return result;
            };
        }
    }
});
```

## å·¥ä½œæµæ“ä½œ

### è‡ªåŠ¨ä¿å­˜å·¥ä½œæµ

```javascript
import { app } from "../../scripts/app.js";

app.registerExtension({
    name: "my.auto.save",
    async setup() {
        let saveTimeout;
        
        // ç›‘å¬å›¾å˜åŒ–
        const originalOnChange = app.graph.onchange;
        app.graph.onchange = function() {
            originalOnChange?.apply(this, arguments);
            
            // å»¶è¿Ÿä¿å­˜ï¼Œé¿å…é¢‘ç¹ä¿å­˜
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                autoSaveWorkflow();
            }, 5000); // 5ç§’åŽä¿å­˜
        };
    }
});

function autoSaveWorkflow() {
    const workflow = app.graph.serialize();
    const timestamp = new Date().toISOString();
    const filename = `auto_save_${timestamp}.json`;
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    localStorage.setItem(`workflow_${timestamp}`, JSON.stringify(workflow));
    
    console.log(`Workflow auto-saved as ${filename}`);
}
```

### æ‰¹é‡èŠ‚ç‚¹æ“ä½œ

```javascript
app.registerExtension({
    name: "my.batch.operations",
    async setup() {
        // æ·»åŠ æ‰¹é‡æ“ä½œèœå•
        const originalGetCanvasMenuOptions = LGraphCanvas.prototype.getCanvasMenuOptions;
        LGraphCanvas.prototype.getCanvasMenuOptions = function() {
            const options = originalGetCanvasMenuOptions.apply(this, arguments);
            
            options.push(null); // åˆ†éš”çº¿
            options.push({
                content: "æ‰¹é‡æ“ä½œ",
                has_submenu: true,
                callback: (value, options, e, menu, node) => {
                    const submenu = new LiteGraph.ContextMenu([
                        "å…¨éƒ¨é™éŸ³",
                        "å…¨éƒ¨å–æ¶ˆé™éŸ³", 
                        "åˆ é™¤æ‰€æœ‰æ–­å¼€è¿žæŽ¥çš„èŠ‚ç‚¹",
                        "å¯¹é½é€‰ä¸­èŠ‚ç‚¹"
                    ], {
                        event: e,
                        callback: (action) => {
                            performBatchOperation(action);
                        },
                        parentMenu: menu
                    });
                }
            });
            
            return options;
        };
    }
});

function performBatchOperation(action) {
    const nodes = app.graph._nodes;
    
    switch(action) {
        case "å…¨éƒ¨é™éŸ³":
            nodes.forEach(node => node.mode = 2);
            break;
            
        case "å…¨éƒ¨å–æ¶ˆé™éŸ³":
            nodes.forEach(node => node.mode = 0);
            break;
            
        case "åˆ é™¤æ‰€æœ‰æ–­å¼€è¿žæŽ¥çš„èŠ‚ç‚¹":
            const connectedNodes = new Set();
            app.graph.links.forEach(link => {
                connectedNodes.add(link.origin_id);
                connectedNodes.add(link.target_id);
            });
            
            nodes.forEach(node => {
                if (!connectedNodes.has(node.id)) {
                    app.graph.remove(node);
                }
            });
            break;
            
        case "å¯¹é½é€‰ä¸­èŠ‚ç‚¹":
            const selectedNodes = app.canvas.selected_nodes;
            if (selectedNodes && Object.keys(selectedNodes).length > 1) {
                const nodeList = Object.values(selectedNodes);
                const minY = Math.min(...nodeList.map(n => n.pos[1]));
                nodeList.forEach(node => {
                    node.pos[1] = minY;
                });
            }
            break;
    }
    
    app.graph.setDirtyCanvas(true, true);
}
