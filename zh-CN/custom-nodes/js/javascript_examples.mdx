---
title: "å¸¦æ³¨é‡Šçš„ç¤ºä¾‹"
---

ä¸æ–­å¢é•¿çš„ç¤ºä¾‹ä»£ç ç‰‡æ®µé›†åˆâ€¦â€¦

## å³é”®èœå•

### èƒŒæ™¯èœå•

ä¸»èƒŒæ™¯èœå•ï¼ˆåœ¨ç”»å¸ƒä¸Šå³é”®ï¼‰æ˜¯é€šè¿‡è°ƒç”¨ `LGraph.getCanvasMenuOptions` ç”Ÿæˆçš„ã€‚æ·»åŠ è‡ªå®šä¹‰èœå•é€‰é¡¹çš„ä¸€ç§æ–¹å¼æ˜¯åŠ«æŒè¿™ä¸ªè°ƒç”¨ï¼š

```Javascript
/* åœ¨ setup() ä¸­ */
    const original_getCanvasMenuOptions = LGraphCanvas.prototype.getCanvasMenuOptions;
    LGraphCanvas.prototype.getCanvasMenuOptions = function () {
        // è·å–åŸºç¡€é€‰é¡¹
        const options = original_getCanvasMenuOptions.apply(this, arguments);
        options.push(null); // æ’å…¥åˆ†éš”çº¿
        options.push({
            content: "èœå•çš„æ–‡æœ¬",
            callback: async () => {
                // æ‰§è¡Œä»»æ„æ“ä½œ
            }
        })
        return options;
    }
```

### èŠ‚ç‚¹èœå•

å½“ä½ åœ¨èŠ‚ç‚¹ä¸Šå³é”®æ—¶ï¼Œèœå•åŒæ ·æ˜¯é€šè¿‡ `node.getExtraMenuOptions` ç”Ÿæˆçš„ã€‚ä½†è¿™æ¬¡ä¸æ˜¯è¿”å›ä¸€ä¸ª options å¯¹è±¡ï¼Œè€Œæ˜¯å°†å…¶ä½œä¸ºå‚æ•°ä¼ å…¥â€¦â€¦

```javascript
/* åœ¨ beforeRegisterNodeDef() ä¸­ */
if (nodeType?.comfyClass=="MyNodeClass") { 
    const original_getExtraMenuOptions = nodeType.prototype.getExtraMenuOptions;
    nodeType.prototype.getExtraMenuOptions = function(_, options) {
        original_getExtraMenuOptions?.apply(this, arguments);
        options.push({
            content: "åšç‚¹æœ‰è¶£çš„äº‹",
            callback: async () => {
                // æœ‰è¶£çš„æ“ä½œ
            }
        })
    }   
}
```

### å­èœå•

å¦‚æœä½ æƒ³è¦å­èœå•ï¼Œå¯ä»¥æä¾›ä¸€ä¸ªå›è°ƒï¼Œä½¿ç”¨ `LiteGraph.ContextMenu` åˆ›å»ºå®ƒï¼š

```javascript
function make_submenu(value, options, e, menu, node) {
    const submenu = new LiteGraph.ContextMenu(
        ["é€‰é¡¹ 1", "é€‰é¡¹ 2", "é€‰é¡¹ 3"],
        { 
            event: e, 
            callback: function (v) { 
                // ç”¨ v (=="é€‰é¡¹ x") åšç‚¹ä»€ä¹ˆ
            }, 
            parentMenu: menu, 
            node:node
        }
    )
}

/* ... */
    options.push(
        {
            content: "å¸¦é€‰é¡¹çš„èœå•",
            has_submenu: true,
            callback: make_submenu,
        }
    )
```

## æ•è· UI äº‹ä»¶

è¿™å’Œä½ é¢„æœŸçš„ä¸€æ ·â€”â€”åœ¨ DOM ä¸­æ‰¾åˆ° UI å…ƒç´ å¹¶æ·»åŠ  eventListenerã€‚`setup()` æ˜¯åšè¿™ä»¶äº‹çš„å¥½åœ°æ–¹ï¼Œå› ä¸ºæ­¤æ—¶é¡µé¢å·²å®Œå…¨åŠ è½½ã€‚ä¾‹å¦‚ï¼Œæ£€æµ‹"é˜Ÿåˆ—"æŒ‰é’®çš„ç‚¹å‡»ï¼š

```Javascript
function queue_button_pressed() { console.log("é˜Ÿåˆ—æŒ‰é’®è¢«æŒ‰ä¸‹ï¼") }
document.getElementById("queue-button").addEventListener("click", queue_button_pressed);
```

## æ£€æµ‹å·¥ä½œæµå¼€å§‹

è¿™æ˜¯ä¼—å¤š `api` äº‹ä»¶ä¹‹ä¸€ï¼š

```javascript
import { api } from "../../scripts/api.js";
/* åœ¨ setup() ä¸­ */
    function on_execution_start() { 
        /* æ‰§è¡Œä»»æ„æ“ä½œ */
    }
    api.addEventListener("execution_start", on_execution_start);
```

## æ£€æµ‹å·¥ä½œæµè¢«ä¸­æ–­

è¿™æ˜¯ä¸€ä¸ªåŠ«æŒ api çš„ç®€å•ä¾‹å­ï¼š

```Javascript
import { api } from "../../scripts/api.js";
/* åœ¨ setup() ä¸­ */
    const original_api_interrupt = api.interrupt;
    api.interrupt = function () {
        /* åœ¨è°ƒç”¨åŸæ–¹æ³•å‰åšç‚¹ä»€ä¹ˆ */
        original_api_interrupt.apply(this, arguments);
        /* æˆ–è€…åœ¨ä¹‹å */
    }
```

## æ•è·èŠ‚ç‚¹ç‚¹å‡»

`node` æœ‰ä¸€ä¸ª mouseDown æ–¹æ³•å¯ä»¥è¢«åŠ«æŒã€‚
è¿™æ¬¡æˆ‘ä»¬æ³¨æ„ä¼ é€’ä»»ä½•è¿”å›å€¼ã€‚

```javascript
async nodeCreated(node) {
    if (node?.comfyClass === "My Node Name") {
        const original_onMouseDown = node.onMouseDown;
        node.onMouseDown = function( e, pos, canvas ) {
            alert("å“å‘¦ï¼");
            return original_onMouseDown?.apply(this, arguments);
        }        
    }
}
```

## è‡ªå®šä¹‰å°éƒ¨ä»¶

### åˆ›å»ºæ»‘å—å°éƒ¨ä»¶

```javascript
app.registerExtension({
    name: "my.custom.slider",
    async getCustomWidgets() {
        return {
            CUSTOM_SLIDER(node, inputName, inputData, app) {
                const widget = node.addWidget("slider", inputName, inputData[1]?.default || 0, (value) => {
                    // å°éƒ¨ä»¶å€¼å˜åŒ–æ—¶çš„å›è°ƒ
                    console.log(`${inputName} changed to: ${value}`);
                }, {
                    min: inputData[1]?.min || 0,
                    max: inputData[1]?.max || 100,
                    step: inputData[1]?.step || 1
                });
                
                return { widget };
            }
        };
    }
});
```

### åˆ›å»ºæ–‡ä»¶ä¸Šä¼ å°éƒ¨ä»¶

```javascript
app.registerExtension({
    name: "my.file.upload",
    async getCustomWidgets() {
        return {
            FILE_UPLOAD(node, inputName, inputData, app) {
                const fileInput = document.createElement("input");
                fileInput.type = "file";
                fileInput.accept = inputData[1]?.accept || "*/*";
                
                fileInput.addEventListener("change", (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
                        const formData = new FormData();
                        formData.append("file", file);
                        
                        fetch("/upload", {
                            method: "POST",
                            body: formData
                        }).then(response => response.json())
                          .then(data => {
                              console.log("File uploaded:", data);
                              // æ›´æ–°èŠ‚ç‚¹çŠ¶æ€
                          });
                    }
                });
                
                const widget = node.addDOMWidget(inputName, "file", fileInput);
                return { widget };
            }
        };
    }
});
```

## èŠ‚ç‚¹é€šä¿¡

### æœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯æ¶ˆæ¯

```javascript
import { api } from "../../scripts/api.js";

app.registerExtension({
    name: "my.server.communication",
    async setup() {
        // ç›‘å¬æ¥è‡ªæœåŠ¡å™¨çš„è‡ªå®šä¹‰æ¶ˆæ¯
        api.addEventListener("my_custom_event", (event) => {
            const data = event.detail;
            console.log("Received from server:", data);
            
            // æ ¹æ®æ¶ˆæ¯æ›´æ–° UI
            if (data.type === "progress") {
                updateProgressBar(data.progress);
            } else if (data.type === "error") {
                showErrorMessage(data.message);
            }
        });
    }
});

function updateProgressBar(progress) {
    // æ›´æ–°è¿›åº¦æ¡æ˜¾ç¤º
    const progressBar = document.getElementById("my-progress-bar");
    if (progressBar) {
        progressBar.style.width = `${progress}%`;
    }
}

function showErrorMessage(message) {
    // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
    alert(`Error: ${message}`);
}
```

### å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨æ¶ˆæ¯

```javascript
import { api } from "../../scripts/api.js";

// å‘é€è‡ªå®šä¹‰æ¶ˆæ¯åˆ°æœåŠ¡å™¨
function sendCustomMessage(nodeId, messageType, data) {
    api.fetchApi("/custom_message", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            node_id: nodeId,
            message_type: messageType,
            data: data
        })
    }).then(response => response.json())
      .then(result => {
          console.log("Server response:", result);
      })
      .catch(error => {
          console.error("Error sending message:", error);
      });
}
```

## é«˜çº§ UI å®šåˆ¶

### è‡ªå®šä¹‰èŠ‚ç‚¹å¤–è§‚

```javascript
app.registerExtension({
    name: "my.custom.appearance",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeType.comfyClass === "MySpecialNode") {
            // è‡ªå®šä¹‰èŠ‚ç‚¹é¢œè‰²
            nodeType.prototype.bgcolor = "#2a2a2a";
            nodeType.prototype.color = "#ffffff";
            
            // è‡ªå®šä¹‰ç»˜åˆ¶æ–¹æ³•
            const originalOnDrawBackground = nodeType.prototype.onDrawBackground;
            nodeType.prototype.onDrawBackground = function(ctx, canvas) {
                // è°ƒç”¨åŸå§‹ç»˜åˆ¶æ–¹æ³•
                originalOnDrawBackground?.apply(this, arguments);
                
                // æ·»åŠ è‡ªå®šä¹‰ç»˜åˆ¶
                ctx.fillStyle = "#ff6b6b";
                ctx.fillRect(this.pos[0] - 5, this.pos[1] - 5, 10, 10);
            };
            
            // è‡ªå®šä¹‰æ ‡é¢˜
            const originalGetTitle = nodeType.prototype.getTitle;
            nodeType.prototype.getTitle = function() {
                const originalTitle = originalGetTitle?.apply(this, arguments) || this.title;
                return `ğŸŒŸ ${originalTitle}`;
            };
        }
    }
});
```

### åŠ¨æ€æ›´æ–°èŠ‚ç‚¹è¾“å…¥

```javascript
app.registerExtension({
    name: "my.dynamic.inputs",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeType.comfyClass === "DynamicInputNode") {
            const originalOnConnectionsChange = nodeType.prototype.onConnectionsChange;
            nodeType.prototype.onConnectionsChange = function(side, slot, connect, link_info, output) {
                const result = originalOnConnectionsChange?.apply(this, arguments);
                
                if (side === 1 && connect) { // è¾“å…¥è¿æ¥
                    // æ ¹æ®è¿æ¥çš„è¾“å‡ºç±»å‹åŠ¨æ€æ·»åŠ è¾“å…¥
                    const outputType = link_info.type;
                    if (outputType === "IMAGE" && !this.inputs.find(input => input.name === "mask")) {
                        this.addInput("mask", "MASK");
                    }
                }
                
                return result;
            };
        }
    }
});
```

## å·¥ä½œæµæ“ä½œ

### è‡ªåŠ¨ä¿å­˜å·¥ä½œæµ

```javascript
import { app } from "../../scripts/app.js";

app.registerExtension({
    name: "my.auto.save",
    async setup() {
        let saveTimeout;
        
        // ç›‘å¬å›¾å˜åŒ–
        const originalOnChange = app.graph.onchange;
        app.graph.onchange = function() {
            originalOnChange?.apply(this, arguments);
            
            // å»¶è¿Ÿä¿å­˜ï¼Œé¿å…é¢‘ç¹ä¿å­˜
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                autoSaveWorkflow();
            }, 5000); // 5ç§’åä¿å­˜
        };
    }
});

function autoSaveWorkflow() {
    const workflow = app.graph.serialize();
    const timestamp = new Date().toISOString();
    const filename = `auto_save_${timestamp}.json`;
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    localStorage.setItem(`workflow_${timestamp}`, JSON.stringify(workflow));
    
    console.log(`Workflow auto-saved as ${filename}`);
}
```

### æ‰¹é‡èŠ‚ç‚¹æ“ä½œ

```javascript
app.registerExtension({
    name: "my.batch.operations",
    async setup() {
        // æ·»åŠ æ‰¹é‡æ“ä½œèœå•
        const originalGetCanvasMenuOptions = LGraphCanvas.prototype.getCanvasMenuOptions;
        LGraphCanvas.prototype.getCanvasMenuOptions = function() {
            const options = originalGetCanvasMenuOptions.apply(this, arguments);
            
            options.push(null); // åˆ†éš”çº¿
            options.push({
                content: "æ‰¹é‡æ“ä½œ",
                has_submenu: true,
                callback: (value, options, e, menu, node) => {
                    const submenu = new LiteGraph.ContextMenu([
                        "å…¨éƒ¨é™éŸ³",
                        "å…¨éƒ¨å–æ¶ˆé™éŸ³", 
                        "åˆ é™¤æ‰€æœ‰æ–­å¼€è¿æ¥çš„èŠ‚ç‚¹",
                        "å¯¹é½é€‰ä¸­èŠ‚ç‚¹"
                    ], {
                        event: e,
                        callback: (action) => {
                            performBatchOperation(action);
                        },
                        parentMenu: menu
                    });
                }
            });
            
            return options;
        };
    }
});

function performBatchOperation(action) {
    const nodes = app.graph._nodes;
    
    switch(action) {
        case "å…¨éƒ¨é™éŸ³":
            nodes.forEach(node => node.mode = 2);
            break;
            
        case "å…¨éƒ¨å–æ¶ˆé™éŸ³":
            nodes.forEach(node => node.mode = 0);
            break;
            
        case "åˆ é™¤æ‰€æœ‰æ–­å¼€è¿æ¥çš„èŠ‚ç‚¹":
            const connectedNodes = new Set();
            app.graph.links.forEach(link => {
                connectedNodes.add(link.origin_id);
                connectedNodes.add(link.target_id);
            });
            
            nodes.forEach(node => {
                if (!connectedNodes.has(node.id)) {
                    app.graph.remove(node);
                }
            });
            break;
            
        case "å¯¹é½é€‰ä¸­èŠ‚ç‚¹":
            const selectedNodes = app.canvas.selected_nodes;
            if (selectedNodes && Object.keys(selectedNodes).length > 1) {
                const nodeList = Object.values(selectedNodes);
                const minY = Math.min(...nodeList.map(n => n.pos[1]));
                nodeList.forEach(node => {
                    node.pos[1] = minY;
                });
            }
            break;
    }
    
    app.graph.setDirtyCanvas(true, true);
}

## è™šæ‹ŸèŠ‚ç‚¹å’Œè‡ªå®šä¹‰å°éƒ¨ä»¶

### åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹

```javascript
// åŸºäº ComfyUI_frontend æºç çš„è™šæ‹ŸèŠ‚ç‚¹å®ç°
app.registerExtension({
  name: "Comfy.VirtualNodes",
  registerCustomNodes() {
    // æ³¨é‡ŠèŠ‚ç‚¹ - ä¸å‚ä¸è®¡ç®—ä½†æä¾›æ–‡æ¡£åŠŸèƒ½
    class NoteNode extends LGraphNode {
      constructor(title) {
        super(title);
        
        // è®¾ç½®èŠ‚ç‚¹å¤–è§‚
        this.color = "#332922";
        this.bgcolor = "#593930";
        this.groupcolor = "#3f251b";
        
        // æ ‡è®°ä¸ºè™šæ‹ŸèŠ‚ç‚¹
        this.isVirtualNode = true;
        this.serialize_widgets = true;
        
        // åˆå§‹åŒ–å±æ€§
        if (!this.properties) {
          this.properties = { text: "" };
        }
        
        // åˆ›å»ºæ–‡æœ¬å°éƒ¨ä»¶
        this.addWidget("text", "note", this.properties.text, (value) => {
          this.properties.text = value;
        }, { multiline: true });
        
        // è®¾ç½®èŠ‚ç‚¹å¤§å°
        this.size = [400, 200];
      }
      
      // é‡å†™åºåˆ—åŒ–æ–¹æ³•
      serialize() {
        const data = super.serialize();
        data.properties = this.properties;
        return data;
      }
      
      // é‡å†™é…ç½®æ–¹æ³•
      configure(data) {
        super.configure(data);
        if (data.properties) {
          this.properties = data.properties;
          if (this.widgets && this.widgets[0]) {
            this.widgets[0].value = this.properties.text;
          }
        }
      }
    }
    
    // Markdown æ³¨é‡ŠèŠ‚ç‚¹
    class MarkdownNoteNode extends LGraphNode {
      constructor(title) {
        super(title);
        
        this.color = "#332922";
        this.bgcolor = "#593930";
        this.groupcolor = "#3f251b";
        this.isVirtualNode = true;
        this.serialize_widgets = true;
        
        if (!this.properties) {
          this.properties = { text: "" };
        }
        
        // ä½¿ç”¨ Markdown å°éƒ¨ä»¶
        ComfyWidgets.MARKDOWN(
          this,
          'text',
          ['STRING', { default: this.properties.text }],
          app
        );
        
        this.size = [400, 300];
      }
    }
    
    // æ³¨å†ŒèŠ‚ç‚¹ç±»å‹
    LiteGraph.registerNodeType("Note", NoteNode);
    LiteGraph.registerNodeType("MarkdownNote", MarkdownNoteNode);
    
    NoteNode.category = "utils";
    MarkdownNoteNode.category = "utils";
  }
});
```

### é«˜çº§åŸå§‹èŠ‚ç‚¹ï¼ˆPrimitive Nodeï¼‰

```javascript
// åŸºäº ComfyUI_frontend æºç çš„é«˜çº§åŸå§‹èŠ‚ç‚¹å®ç°
class AdvancedPrimitiveNode extends LGraphNode {
  constructor(title) {
    super(title);
    
    // æ·»åŠ è¾“å‡ºè¿æ¥
    this.addOutput("connect to widget input", "*");
    this.serialize_widgets = true;
    this.isVirtualNode = true;
    
    // æ§åˆ¶å€¼æ•°ç»„ï¼Œç”¨äºå­˜å‚¨ä¸åŒç±»å‹çš„å€¼
    this.controlValues = [];
    this.lastType = null;
    
    // æ›¿æ¢å±æ€§åç§°
    const replacePropertyName = "Replace widget with input";
    if (!this.properties || !(replacePropertyName in this.properties)) {
      this.addProperty(replacePropertyName, false, "boolean");
    }
  }
  
  // åº”ç”¨åˆ°å›¾å½¢æ—¶çš„é…ç½®
  applyToGraph(extraLinks = []) {
    if (!this.outputs[0].links?.length) return;
    
    const links = [...this.outputs[0].links, ...extraLinks];
    
    // ä¸ºæ¯ä¸ªè¿æ¥çš„èŠ‚ç‚¹é…ç½®å°éƒ¨ä»¶
    for (const linkId of links) {
      const link = this.graph.links[linkId];
      if (!link) continue;
      
      const node = this.graph.getNodeById(link.target_id);
      const input = node.inputs[link.target_slot];
      
      if (input.widget) {
        this.configureWidgetForNode(node, input);
      }
    }
  }
  
  // ä¸ºèŠ‚ç‚¹é…ç½®å°éƒ¨ä»¶
  configureWidgetForNode(node, input) {
    const widgetName = input.widget.name;
    const widget = node.widgets?.find(w => w.name === widgetName);
    
    if (widget) {
      // è®¾ç½®å°éƒ¨ä»¶é…ç½®è·å–å‡½æ•°
      if (!input.widget.getConfig) {
        input.widget.getConfig = () => this.getWidgetConfig(widgetName);
      }
      
      // åŒæ­¥å°éƒ¨ä»¶å€¼
      if (this.controlValues.length > 0) {
        widget.value = this.controlValues[0];
      }
    }
  }
  
  // è¿æ¥å˜åŒ–æ—¶çš„å¤„ç†
  onConnectionsChange(type, slotIndex, isConnected, linkInfo, ioSlot) {
    if (type === LiteGraph.OUTPUT) {
      if (isConnected) {
        this.onFirstConnection(linkInfo, ioSlot);
      } else if (!this.outputs[0].links?.length) {
        this.onLastDisconnect();
      }
    }
  }
  
  // ç¬¬ä¸€æ¬¡è¿æ¥æ—¶çš„å¤„ç†
  onFirstConnection(linkInfo, ioSlot) {
    const node = this.graph.getNodeById(linkInfo.target_id);
    const input = node.inputs[linkInfo.target_slot];
    
    if (input.widget) {
      this.createWidgetForInput(input);
    }
  }
  
  // ä¸ºè¾“å…¥åˆ›å»ºå°éƒ¨ä»¶
  createWidgetForInput(input) {
    const widgetType = input.type;
    const config = input.widget?.getConfig?.() || [null, {}];
    
    // ç§»é™¤ç°æœ‰å°éƒ¨ä»¶
    this.removeWidgets();
    
    // åˆ›å»ºæ–°å°éƒ¨ä»¶
    let widget;
    if (widgetType in ComfyWidgets) {
      widget = ComfyWidgets[widgetType](this, "value", config, app);
    } else {
      // é»˜è®¤æ–‡æœ¬å°éƒ¨ä»¶
      widget = this.addWidget("text", "value", "", null, config[1]);
    }
    
    if (widget) {
      widget.type = widgetType;
      this.controlValues = [widget.value];
      
      // è®¾ç½®å°éƒ¨ä»¶å›è°ƒ
      const originalCallback = widget.callback;
      widget.callback = (value) => {
        this.controlValues[0] = value;
        this.propagateValue(value);
        if (originalCallback) {
          originalCallback.call(widget, value);
        }
      };
    }
  }
  
  // ä¼ æ’­å€¼åˆ°è¿æ¥çš„èŠ‚ç‚¹
  propagateValue(value) {
    if (!this.outputs[0].links) return;
    
    for (const linkId of this.outputs[0].links) {
      const link = this.graph.links[linkId];
      if (!link) continue;
      
      const node = this.graph.getNodeById(link.target_id);
      const input = node.inputs[link.target_slot];
      
      if (input.widget) {
        const widget = node.widgets?.find(w => w.name === input.widget.name);
        if (widget && widget.value !== value) {
          widget.value = value;
          if (widget.callback) {
            widget.callback(value);
          }
        }
      }
    }
  }
  
  // ç§»é™¤æ‰€æœ‰å°éƒ¨ä»¶
  removeWidgets() {
    if (this.widgets) {
      for (let i = this.widgets.length - 1; i >= 0; i--) {
        this.removeWidget(i);
      }
    }
  }
  
  // æœ€åä¸€ä¸ªè¿æ¥æ–­å¼€æ—¶çš„å¤„ç†
  onLastDisconnect() {
    this.removeWidgets();
    this.controlValues = [];
    this.lastType = null;
  }
}

// æ³¨å†Œé«˜çº§åŸå§‹èŠ‚ç‚¹
app.registerExtension({
  name: "Comfy.AdvancedPrimitiveNode",
  registerCustomNodes() {
    LiteGraph.registerNodeType("AdvancedPrimitiveNode", AdvancedPrimitiveNode);
    AdvancedPrimitiveNode.category = "utils";
  }
});
```

### å°éƒ¨ä»¶è¾“å…¥è½¬æ¢ç³»ç»Ÿ

```javascript
// åŸºäº ComfyUI_frontend çš„å°éƒ¨ä»¶è¾“å…¥è½¬æ¢å®ç°
app.registerExtension({
  name: "Comfy.WidgetInputConversion",
  
  beforeRegisterNodeDef(nodeType, nodeData, app) {
    // å›¾å½¢é…ç½®æ—¶çš„å¤„ç†
    const originalOnGraphConfigured = nodeType.prototype.onGraphConfigured;
    nodeType.prototype.onGraphConfigured = function() {
      if (originalOnGraphConfigured) {
        originalOnGraphConfigured.apply(this, arguments);
      }
      
      if (!this.inputs) return;
      this.widgets = this.widgets || [];
      
      // å¤„ç†è¾“å…¥å°éƒ¨ä»¶
      for (const input of this.inputs) {
        if (input.widget) {
          const name = input.widget.name;
          
          // è®¾ç½®é…ç½®è·å–å‡½æ•°
          if (!input.widget.getConfig) {
            input.widget.getConfig = () => this.getWidgetConfig(name);
          }
          
          // æ£€æŸ¥å¯¹åº”çš„å°éƒ¨ä»¶æ˜¯å¦å­˜åœ¨
          const widget = this.widgets.find(w => w.name === name);
          if (!widget) {
            // ç§»é™¤æ— æ•ˆçš„è¾“å…¥
            const inputIndex = this.inputs.findIndex(i => i === input);
            this.removeInput(inputIndex);
          }
        }
      }
    };
    
    // åŒå‡»è¾“å…¥è‡ªåŠ¨è¿æ¥åŸå§‹èŠ‚ç‚¹
    const originalOnInputDblClick = nodeType.prototype.onInputDblClick;
    nodeType.prototype.onInputDblClick = function(slot, ...args) {
      const result = originalOnInputDblClick?.apply(this, [slot, ...args]);
      
      const input = this.inputs[slot];
      if (!input.widget) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ”¯æŒçš„è¾“å…¥ç±»å‹
        if (!(input.type in ComfyWidgets) && 
            !this.isComboInput(input)) {
          return result;
        }
      }
      
      // åˆ›å»ºåŸå§‹èŠ‚ç‚¹
      const primitiveNode = LiteGraph.createNode("PrimitiveNode");
      if (!primitiveNode) return result;
      
      app.graph.add(primitiveNode);
      
      // è®¡ç®—ä¸é‡å çš„ä½ç½®
      const pos = [this.pos[0] - primitiveNode.size[0] - 30, this.pos[1]];
      while (this.isNodeAtPosition(pos)) {
        pos[1] += LiteGraph.NODE_TITLE_HEIGHT;
      }
      
      primitiveNode.pos = pos;
      primitiveNode.connect(0, this, slot);
      primitiveNode.title = input.name;
      
      return result;
    };
    
    // è¾…åŠ©æ–¹æ³•ï¼šæ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰èŠ‚ç‚¹
    nodeType.prototype.isNodeAtPosition = function(pos) {
      for (const node of app.graph.nodes) {
        if (node.pos[0] === pos[0] && node.pos[1] === pos[1]) {
          return true;
        }
      }
      return false;
    };
    
    // è¾…åŠ©æ–¹æ³•ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯ç»„åˆè¾“å…¥
    nodeType.prototype.isComboInput = function(input) {
      const config = input.widget?.getConfig?.();
      return config && config[0] instanceof Array;
    };
    
    // è¾…åŠ©æ–¹æ³•ï¼šè·å–å°éƒ¨ä»¶é…ç½®
    nodeType.prototype.getWidgetConfig = function(name) {
      const widget = this.widgets?.find(w => w.name === name);
      if (!widget) return [null, {}];
      
      // è¿”å›å°éƒ¨ä»¶çš„ç±»å‹å’Œé…ç½®
      return [widget.type, widget.options || {}];
    };
  }
});
```

## é«˜çº§è‡ªå®šä¹‰å°éƒ¨ä»¶

### é¢œè‰²é€‰æ‹©å™¨å°éƒ¨ä»¶

```javascript
app.registerExtension({
  name: "Comfy.ColorPickerWidget",
  init() {
    // é¢œè‰²é€‰æ‹©å™¨å°éƒ¨ä»¶
    function ColorPickerWidget(node, inputName, inputData, app) {
      const widget = node.addWidget("text", inputName, "#ffffff", function(value) {
        // éªŒè¯é¢œè‰²æ ¼å¼
        if (!/^#[0-9A-F]{6}$/i.test(value)) {
          value = "#ffffff";
        }
        this.value = value;
      });
      
      widget.type = "color_picker";
      
      // è‡ªå®šä¹‰ç»˜åˆ¶
      const originalDraw = widget.draw;
      widget.draw = function(ctx, node, width, y, height) {
        // ç»˜åˆ¶é¢œè‰²é¢„è§ˆ
        ctx.fillStyle = this.value;
        ctx.fillRect(width - 30, y + 2, 25, height - 4);
        
        // ç»˜åˆ¶è¾¹æ¡†
        ctx.strokeStyle = "#666";
        ctx.strokeRect(width - 30, y + 2, 25, height - 4);
        
        // è°ƒç”¨åŸå§‹ç»˜åˆ¶æ–¹æ³•
        if (originalDraw) {
          originalDraw.call(this, ctx, node, width - 35, y, height);
        }
      };
      
      // æ·»åŠ ç‚¹å‡»äº‹ä»¶
      widget.mouse = function(event, pos, node) {
        if (event.type === "pointerdown") {
          // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†é¢œè‰²é¢„è§ˆåŒºåŸŸ
          const rect = node.getBounding();
          const x = pos[0] - rect[0];
          const y = pos[1] - rect[1];
          
          if (x > node.size[0] - 30 && x < node.size[0] - 5) {
            // æ‰“å¼€é¢œè‰²é€‰æ‹©å™¨
            this.openColorPicker();
            return true;
          }
        }
        return false;
      };
      
      widget.openColorPicker = function() {
        // åˆ›å»ºé¢œè‰²é€‰æ‹©å™¨è¾“å…¥
        const input = document.createElement("input");
        input.type = "color";
        input.value = this.value;
        input.style.position = "absolute";
        input.style.left = "-9999px";
        
        input.addEventListener("change", (e) => {
          this.value = e.target.value;
          document.body.removeChild(input);
        });
        
        document.body.appendChild(input);
        input.click();
      };
      
      return widget;
    }
    
    // æ³¨å†Œè‡ªå®šä¹‰å°éƒ¨ä»¶
    ComfyWidgets.COLOR_PICKER = ColorPickerWidget;
  }
});
```

### èŒƒå›´æ»‘å—å°éƒ¨ä»¶

```javascript
app.registerExtension({
  name: "Comfy.RangeSliderWidget",
  init() {
    // èŒƒå›´æ»‘å—å°éƒ¨ä»¶
    function RangeSliderWidget(node, inputName, inputData, app) {
      const config = inputData[1] || {};
      const min = config.min || 0;
      const max = config.max || 100;
      const step = config.step || 1;
      const defaultValue = config.default || [min, max];
      
      const widget = node.addWidget("text", inputName, `${defaultValue[0]}-${defaultValue[1]}`, function(value) {
        // è§£æèŒƒå›´å€¼
        const parts = value.split("-");
        if (parts.length === 2) {
          const low = Math.max(min, Math.min(max, parseFloat(parts[0]) || min));
          const high = Math.max(low, Math.min(max, parseFloat(parts[1]) || max));
          this.value = `${low}-${high}`;
          this.range = [low, high];
        }
      });
      
      widget.type = "range_slider";
      widget.range = defaultValue;
      
      // è‡ªå®šä¹‰ç»˜åˆ¶
      widget.draw = function(ctx, node, width, y, height) {
        const range = this.range || [min, max];
        const lowPercent = (range[0] - min) / (max - min);
        const highPercent = (range[1] - min) / (max - min);
        
        // ç»˜åˆ¶æ»‘å—è½¨é“
        ctx.fillStyle = "#333";
        ctx.fillRect(10, y + height/2 - 2, width - 20, 4);
        
        // ç»˜åˆ¶é€‰ä¸­èŒƒå›´
        const startX = 10 + (width - 20) * lowPercent;
        const endX = 10 + (width - 20) * highPercent;
        ctx.fillStyle = "#4a9eff";
        ctx.fillRect(startX, y + height/2 - 2, endX - startX, 4);
        
        // ç»˜åˆ¶æ»‘å—æ‰‹æŸ„
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(startX, y + height/2, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(endX, y + height/2, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // ç»˜åˆ¶æ•°å€¼
        ctx.fillStyle = "#fff";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.value, width/2, y + height - 5);
      };
      
      return widget;
    }
    
    // æ³¨å†Œè‡ªå®šä¹‰å°éƒ¨ä»¶
    ComfyWidgets.RANGE_SLIDER = RangeSliderWidget;
  }
});
```

## èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸç®¡ç†

### å®Œæ•´çš„èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸå¤„ç†

```javascript
app.registerExtension({
  name: "Comfy.NodeLifecycleManager",
  
  nodeCreated(node, app) {
    // èŠ‚ç‚¹åˆ›å»ºæ—¶çš„åˆå§‹åŒ–
    console.log(`èŠ‚ç‚¹å·²åˆ›å»º: ${node.type}`);
    
    // æ·»åŠ åˆ›å»ºæ—¶é—´æˆ³
    node.createdAt = Date.now();
    
    // ä¸ºç‰¹å®šç±»å‹çš„èŠ‚ç‚¹æ·»åŠ é¢å¤–åŠŸèƒ½
    if (node.type === "MyCustomNode") {
      this.setupCustomNode(node);
    }
    
    // æ·»åŠ é€šç”¨çš„èŠ‚ç‚¹ç»Ÿè®¡åŠŸèƒ½
    this.addNodeStatistics(node);
  },
  
  setupCustomNode(node) {
    // æ·»åŠ è‡ªå®šä¹‰å±æ€§
    node.customData = {
      processCount: 0,
      lastProcessTime: null,
      errors: [],
      performance: {
        totalTime: 0,
        averageTime: 0
      }
    };
    
    // é‡å†™èŠ‚ç‚¹çš„æ‰§è¡Œæ–¹æ³•
    const originalOnExecuted = node.onExecuted;
    node.onExecuted = function(message) {
      const startTime = Date.now();
      
      this.customData.processCount++;
      this.customData.lastProcessTime = startTime;
      
      // æ›´æ–°èŠ‚ç‚¹æ ‡é¢˜æ˜¾ç¤ºå¤„ç†æ¬¡æ•°
      this.title = `${this.type} (${this.customData.processCount})`;
      
      if (originalOnExecuted) {
        originalOnExecuted.call(this, message);
      }
      
      // è®¡ç®—æ€§èƒ½ç»Ÿè®¡
      const endTime = Date.now();
      const executionTime = endTime - startTime;
      this.customData.performance.totalTime += executionTime;
      this.customData.performance.averageTime = 
        this.customData.performance.totalTime / this.customData.processCount;
    };
    
    // æ·»åŠ é”™è¯¯å¤„ç†
    const originalOnExecutionError = node.onExecutionError;
    node.onExecutionError = function(error) {
      this.customData.errors.push({
        error: error,
        timestamp: Date.now()
      });
      
      // é™åˆ¶é”™è¯¯å†å²è®°å½•æ•°é‡
      if (this.customData.errors.length > 10) {
        this.customData.errors.shift();
      }
      
      // æ›´æ–°èŠ‚ç‚¹å¤–è§‚æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
      this.bgcolor = "#4a1a1a"; // çº¢è‰²èƒŒæ™¯è¡¨ç¤ºé”™è¯¯
      
      if (originalOnExecutionError) {
        originalOnExecutionError.call(this, error);
      }
    };
  },
  
  addNodeStatistics(node) {
    // æ·»åŠ å³é”®èœå•é€‰é¡¹
    const originalGetMenuOptions = node.getMenuOptions;
    node.getMenuOptions = function() {
      const options = originalGetMenuOptions ? originalGetMenuOptions.call(this) : [];
      
      options.push(null); // åˆ†éš”çº¿
      options.push({
        content: "ğŸ“Š æŸ¥çœ‹èŠ‚ç‚¹ç»Ÿè®¡",
        callback: () => {
          this.showNodeStatistics();
        }
      });
      
      if (this.customData && this.customData.errors.length > 0) {
        options.push({
          content: "ğŸ—‘ï¸ æ¸…é™¤é”™è¯¯å†å²",
          callback: () => {
            this.customData.errors = [];
            this.bgcolor = null; // æ¢å¤é»˜è®¤èƒŒæ™¯è‰²
            console.log("é”™è¯¯å†å²å·²æ¸…é™¤");
          }
        });
      }
      
      options.push({
        content: "ğŸ”„ é‡ç½®ç»Ÿè®¡æ•°æ®",
        callback: () => {
          if (this.customData) {
            this.customData.processCount = 0;
            this.customData.errors = [];
            this.customData.performance = { totalTime: 0, averageTime: 0 };
            this.title = this.type; // æ¢å¤åŸå§‹æ ‡é¢˜
            this.bgcolor = null; // æ¢å¤é»˜è®¤èƒŒæ™¯è‰²
          }
          console.log("ç»Ÿè®¡æ•°æ®å·²é‡ç½®");
        }
      });
      
      return options;
    };
    
    // æ·»åŠ ç»Ÿè®¡æ˜¾ç¤ºæ–¹æ³•
    node.showNodeStatistics = function() {
      let stats = `èŠ‚ç‚¹ç±»å‹: ${this.type}\n`;
      stats += `åˆ›å»ºæ—¶é—´: ${new Date(this.createdAt).toLocaleString()}\n`;
      
      if (this.customData) {
        stats += `å¤„ç†æ¬¡æ•°: ${this.customData.processCount}\n`;
        stats += `æœ€åå¤„ç†æ—¶é—´: ${this.customData.lastProcessTime ? 
          new Date(this.customData.lastProcessTime).toLocaleString() : 'æœªå¤„ç†'}\n`;
        stats += `é”™è¯¯æ¬¡æ•°: ${this.customData.errors.length}\n`;
        
        if (this.customData.performance.averageTime > 0) {
          stats += `å¹³å‡æ‰§è¡Œæ—¶é—´: ${this.customData.performance.averageTime.toFixed(2)}ms\n`;
          stats += `æ€»æ‰§è¡Œæ—¶é—´: ${this.customData.performance.totalTime}ms\n`;
        }
        
        if (this.customData.errors.length > 0) {
          stats += `\næœ€è¿‘é”™è¯¯:\n`;
          this.customData.errors.slice(-3).forEach((error, index) => {
            stats += `${index + 1}. ${new Date(error.timestamp).toLocaleString()}: ${error.error}\n`;
          });
        }
      }
      
      // åˆ›å»ºç»Ÿè®¡ä¿¡æ¯å¯¹è¯æ¡†
      const dialog = document.createElement("div");
      dialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #2a2a2a;
        color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        z-index: 10000;
        max-width: 500px;
        font-family: monospace;
        white-space: pre-line;
      `;
      
      dialog.innerHTML = `
        <h3 style="margin-top: 0;">èŠ‚ç‚¹ç»Ÿè®¡ä¿¡æ¯</h3>
        <div style="margin: 10px 0;">${stats}</div>
        <button onclick="this.parentElement.remove()" style="
          background: #4a9eff;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
        ">å…³é—­</button>
      `;
      
      document.body.appendChild(dialog);
    };
  }
});
```
