---
title: "开发技巧"
---

## 推荐的开发生命周期

### 1. 项目设置

**使用 comfy-cli 快速开始**
```bash
comfy node init my-custom-node
cd my-custom-node
```

**手动设置项目结构**
```
my-custom-node/
├── __init__.py          # 节点注册
├── my_node.py          # 主要节点实现
├── requirements.txt    # Python 依赖
├── web/               # 前端资源
│   ├── js/
│   │   └── my_node.js # JavaScript 扩展
│   └── docs/          # 节点文档
└── example_workflows/ # 示例工作流
```

### 2. 开发工作流

1. **先实现 Python 后端**
   - 定义 `INPUT_TYPES` 和 `RETURN_TYPES`
   - 实现主要处理函数
   - 测试基本功能

2. **添加 JavaScript 前端（如需要）**
   - 创建扩展文件
   - 注册钩子和事件处理器
   - 测试 UI 交互

3. **迭代测试和优化**
   - 在 ComfyUI 中加载测试
   - 检查控制台错误
   - 优化性能

## 调试技巧

### Python 调试

**使用日志记录**
```python
import logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def my_function(self, input_data):
    logger.debug(f"Processing input: {input_data}")
    # 处理逻辑
    logger.debug(f"Output: {result}")
    return result
```

**检查输入数据**
```python
def my_function(self, image, strength):
    print(f"Image shape: {image.shape}")
    print(f"Image dtype: {image.dtype}")
    print(f"Strength value: {strength}")
    # 确保数据类型正确
    assert isinstance(strength, float), f"Expected float, got {type(strength)}"
```

**处理异常**
```python
def my_function(self, input_data):
    try:
        result = process_data(input_data)
        return (result,)
    except Exception as e:
        print(f"Error in {self.__class__.__name__}: {e}")
        import traceback
        traceback.print_exc()
        raise
```

### JavaScript 调试

**使用浏览器开发者工具**
```javascript
app.registerExtension({
    name: "my.extension",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        console.log("Registering node:", nodeData.name);
        console.log("Node data:", nodeData);
        
        if (nodeType.comfyClass === "MyNode") {
            console.log("Found my node!");
            // 在此处设置断点
            debugger;
        }
    }
});
```

**监控节点事件**
```javascript
async nodeCreated(node) {
    if (node.comfyClass === "MyNode") {
        console.log("My node created:", node);
        
        // 监控小部件变化
        node.widgets?.forEach(widget => {
            const originalCallback = widget.callback;
            widget.callback = function(value) {
                console.log(`Widget ${widget.name} changed to:`, value);
                return originalCallback?.apply(this, arguments);
            };
        });
    }
}
```

## 性能优化

### Python 性能

**避免不必要的计算**
```python
def my_function(self, image, enable_processing):
    if not enable_processing:
        return (image,)  # 直接返回，避免处理
    
    # 只在需要时进行昂贵的计算
    result = expensive_operation(image)
    return (result,)
```

**使用延迟求值**
```python
@classmethod
def INPUT_TYPES(cls):
    return {
        "required": {
            "image1": ("IMAGE", {"lazy": True}),
            "image2": ("IMAGE", {"lazy": True}),
            "mode": (["blend", "image1_only", "image2_only"],),
        }
    }

def check_lazy_status(self, mode, image1, image2):
    needed = []
    if mode != "image2_only" and image1 is None:
        needed.append("image1")
    if mode != "image1_only" and image2 is None:
        needed.append("image2")
    return needed
```

**内存管理**
```python
import torch

def my_function(self, large_tensor):
    # 在 GPU 上处理时注意内存
    if large_tensor.device.type == 'cuda':
        torch.cuda.empty_cache()
    
    # 及时释放不需要的张量
    intermediate = process_step1(large_tensor)
    result = process_step2(intermediate)
    del intermediate  # 显式删除
    
    return (result,)
```

### JavaScript 性能

**避免频繁的 DOM 操作**
```javascript
// 不好的做法
for (let i = 0; i < 1000; i++) {
    document.getElementById("myElement").innerHTML += `<div>${i}</div>`;
}

// 好的做法
let html = "";
for (let i = 0; i < 1000; i++) {
    html += `<div>${i}</div>`;
}
document.getElementById("myElement").innerHTML = html;
```

## 最佳实践

### 代码组织

**模块化设计**
```python
# utils.py
def validate_image(image):
    if not isinstance(image, torch.Tensor):
        raise ValueError("Expected torch.Tensor")
    if len(image.shape) != 4:
        raise ValueError("Expected 4D tensor [B,H,W,C]")

# my_node.py
from .utils import validate_image

class MyNode:
    def my_function(self, image):
        validate_image(image)
        # 处理逻辑
```

**错误处理**
```python
class MyNode:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image": ("IMAGE",),
                "strength": ("FLOAT", {"default": 1.0, "min": 0.0, "max": 2.0}),
            }
        }
    
    @classmethod
    def VALIDATE_INPUTS(cls, image, strength):
        if strength < 0 or strength > 2:
            return "Strength must be between 0 and 2"
        return True
```

### 用户体验

**提供有意义的节点名称和类别**
```python
class ImageEnhancer:
    CATEGORY = "image/enhancement"
    FUNCTION = "enhance"
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image": ("IMAGE",),
                "enhancement_type": (["sharpen", "denoise", "upscale"],),
            }
        }
```

**添加节点文档**
```markdown
# 图像增强器

这个节点提供多种图像增强功能。

## 参数

- **image**: 输入图像
- **enhancement_type**: 增强类型
  - `sharpen`: 锐化图像
  - `denoise`: 降噪处理
  - `upscale`: 放大图像

## 使用示例

连接图像加载节点到此节点的 image 输入，选择所需的增强类型。
```

## 测试策略

### 单元测试

**测试节点功能**
```python
import unittest
import torch
from my_node import MyNode

class TestMyNode(unittest.TestCase):
    def setUp(self):
        self.node = MyNode()
        self.test_image = torch.randn(1, 512, 512, 3)
    
    def test_basic_functionality(self):
        result = self.node.my_function(self.test_image, 1.0)
        self.assertIsInstance(result, tuple)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0].shape, self.test_image.shape)
    
    def test_edge_cases(self):
        # 测试边界值
        result = self.node.my_function(self.test_image, 0.0)
        torch.testing.assert_close(result[0], self.test_image)
```

### 集成测试

**在 ComfyUI 中测试**
1. 重启 ComfyUI 服务器
2. 检查控制台是否有加载错误
3. 创建包含你的节点的工作流
4. 测试各种输入组合
5. 验证输出结果

## 常见陷阱

### Python 陷阱

**忘记返回元组**
```python
# 错误
def my_function(self, image):
    return processed_image

# 正确
def my_function(self, image):
    return (processed_image,)
```

**张量形状不匹配**
```python
# 检查并调整形状
def my_function(self, image):
    if len(image.shape) == 3:  # [H,W,C]
        image = image.unsqueeze(0)  # 添加批次维度 [1,H,W,C]
    
    # 处理逻辑
    result = process(image)
    return (result,)
```

**设备不匹配**
```python
def my_function(self, image, mask):
    # 确保张量在同一设备上
    if image.device != mask.device:
        mask = mask.to(image.device)
    
    result = image * mask
    return (result,)
```

### JavaScript 陷阱

**异步操作处理**
```javascript
// 错误 - 没有等待异步操作
async beforeRegisterNodeDef(nodeType, nodeData, app) {
    if (nodeType.comfyClass === "MyNode") {
        loadSomeData();  // 异步操作
        // 可能在数据加载完成前就继续执行
    }
}

// 正确
async beforeRegisterNodeDef(nodeType, nodeData, app) {
    if (nodeType.comfyClass === "MyNode") {
        await loadSomeData();  // 等待异步操作完成
    }
}
```

**内存泄漏**
```javascript
// 记得清理事件监听器
async nodeCreated(node) {
    if (node.comfyClass === "MyNode") {
        const handler = () => { /* 处理逻辑 */ };
        document.addEventListener("click", handler);
        
        // 在节点销毁时清理
        const originalOnRemoved = node.onRemoved;
        node.onRemoved = function() {
            document.removeEventListener("click", handler);
            return originalOnRemoved?.apply(this, arguments);
        };
    }
}
```

## 开发环境设置

### 推荐工具

**Python 开发**
- IDE: PyCharm, VSCode
- 调试: pdb, ipdb
- 代码格式化: black, autopep8
- 类型检查: mypy

**JavaScript 开发**
- 浏览器开发者工具
- 代码格式化: prettier
- 语法检查: eslint

### 热重载设置

**Python 热重载**
```python
# 在开发时添加到 __init__.py
import importlib
import sys

# 重新加载模块
if "my_node" in sys.modules:
    importlib.reload(sys.modules["my_node"])

from .my_node import MyNode
```

**JavaScript 热重载**
- 修改 JavaScript 文件后刷新浏览器页面
- 使用浏览器的硬刷新 (Ctrl+F5) 清除缓存
