---
title: "Subgraphs (Python)"
description: "How UNIQUE_ID and execution behave when your Python node runs inside a subgraph."
---

## UNIQUE_ID in Subgraphs

When a Python node executes inside a subgraph, its `UNIQUE_ID` becomes a colon-separated
execution path instead of a simple number.

| Context | UNIQUE_ID | Meaning |
|---------|-----------|---------|
| Root graph | `"789"` | Node 789 at top level |
| One level deep | `"45:789"` | Node 789 inside subgraph-node 45 |
| Two levels deep | `"12:45:789"` | Node 789 → subgraph 45 → subgraph 12 |

```python
def process(self, **kwargs):
    unique_id = kwargs.get('unique_id', '')
    # Always get local ID from the last segment
    local_id = unique_id.split(':')[-1]

    # Use the full unique_id for cache keys and logging
    cache_key = f"my_node_{unique_id}"
```

<Warning>
Never assume `UNIQUE_ID` is a simple integer. Always treat it as a string and split on `:`
when you need the local ID.
</Warning>

## Execution Flattening

At execution time, the frontend flattens the subgraph hierarchy into a flat list of nodes.
Each gets a compound execution ID. The backend sees only the flattened graph — it has no
awareness of the subgraph structure.

For runtime subgraph creation in Python, see [Node Expansion](/custom-nodes/backend/expansion).

For the frontend developer guide, see [Subgraphs](/custom-nodes/js/subgraphs).
