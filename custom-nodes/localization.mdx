---
title: "Localization and Internationalization"
---

ComfyUI provides comprehensive support for localizing custom nodes, allowing developers to create nodes that work seamlessly across different languages and regions.

## Overview

ComfyUI's localization system automatically scans custom node directories for translation files and makes them available to both the backend and frontend. The system supports multiple languages and provides APIs for dynamic language switching.

## File Structure

Custom nodes should organize their localization files in the following structure:

```
custom_nodes/
└── your_node_pack/
    ├── __init__.py
    ├── nodes.py
    └── locales/
        ├── en/
        │   ├── main.json
        │   ├── commands.json
        │   └── settings.json
        ├── zh/
        │   ├── main.json
        │   ├── commands.json
        │   └── settings.json
        ├── ja/
        │   ├── main.json
        │   ├── commands.json
        │   └── settings.json
        └── fr/
            ├── main.json
            ├── commands.json
            └── settings.json
```

## Translation File Types

### main.json
Contains translations for node definitions, descriptions, and core functionality:

```json
{
  "nodes": {
    "MyCustomNode": {
      "title": "My Custom Node",
      "description": "A powerful image processing node",
      "inputs": {
        "image": "Input Image",
        "strength": "Processing Strength",
        "mode": "Processing Mode"
      },
      "outputs": {
        "result": "Processed Image"
      },
      "modes": {
        "enhance": "Enhance",
        "denoise": "Denoise", 
        "sharpen": "Sharpen"
      }
    }
  },
  "categories": {
    "image/processing": "Image Processing",
    "utilities": "Utilities"
  }
}
```

### commands.json
Contains translations for menu items and user actions:

```json
{
  "menu": {
    "process_image": "Process Image",
    "reset_settings": "Reset Settings",
    "export_result": "Export Result"
  },
  "actions": {
    "processing": "Processing...",
    "complete": "Processing Complete",
    "error": "Processing Error"
  }
}
```

### settings.json
Contains translations for configuration options:

```json
{
  "settings": {
    "enable_gpu": "Enable GPU Acceleration",
    "memory_limit": "Memory Limit (GB)",
    "cache_size": "Cache Size",
    "auto_save": "Auto-save Results"
  },
  "tooltips": {
    "enable_gpu": "Use GPU for faster processing when available",
    "memory_limit": "Maximum memory usage for this node",
    "cache_size": "Number of results to keep in cache"
  }
}
```

## Backend Integration

### Automatic Translation Loading

ComfyUI automatically loads translations when the server starts:

```python
import os
import json
from pathlib import Path

def load_translations():
    """Load translations for this custom node pack."""
    current_dir = Path(__file__).parent
    locales_dir = current_dir / "locales"
    
    translations = {}
    
    if locales_dir.exists():
        for lang_dir in locales_dir.iterdir():
            if lang_dir.is_dir():
                lang_code = lang_dir.name
                translations[lang_code] = {}
                
                for json_file in lang_dir.glob("*.json"):
                    try:
                        with open(json_file, 'r', encoding='utf-8') as f:
                            translations[lang_code][json_file.stem] = json.load(f)
                    except Exception as e:
                        print(f"Error loading translation {json_file}: {e}")
    
    return translations

TRANSLATIONS = load_translations()
```

### Using Translations in Nodes

```python
from comfy.comfy_types import IO, ComfyNodeABC, InputTypeDict

class LocalizedNode(ComfyNodeABC):
    """A node that supports multiple languages."""
    
    @classmethod
    def get_translation(cls, key, lang="en", default=None):
        """Get translation for a specific key and language."""
        try:
            keys = key.split('.')
            value = TRANSLATIONS.get(lang, {}).get('main', {})
            
            for k in keys:
                value = value.get(k, {})
            
            return value if isinstance(value, str) else default or key
        except:
            return default or key
    
    @classmethod
    def INPUT_TYPES(cls) -> InputTypeDict:
        current_lang = cls.get_current_language()
        
        return {
            "required": {
                "image": (IO.IMAGE, {
                    "tooltip": cls.get_translation("nodes.LocalizedNode.inputs.image", current_lang)
                }),
                "strength": (IO.FLOAT, {
                    "default": 1.0,
                    "min": 0.0,
                    "max": 2.0,
                    "tooltip": cls.get_translation("nodes.LocalizedNode.inputs.strength", current_lang)
                }),
                "mode": (["enhance", "denoise", "sharpen"], {
                    "default": "enhance",
                    "tooltip": cls.get_translation("nodes.LocalizedNode.inputs.mode", current_lang)
                }),
            }
        }
    
    @classmethod
    def get_current_language(cls):
        """Get the current language setting from ComfyUI."""
        return "en"
    
    RETURN_TYPES = (IO.IMAGE,)
    FUNCTION = "process"
    CATEGORY = "localized"
    
    def process(self, image, strength, mode):
        return (image,)
```

## Frontend Integration

### Accessing Translations in JavaScript

```javascript
import { api } from "../../scripts/api.js";

class LocalizationManager {
    constructor() {
        this.translations = {};
        this.currentLanguage = 'en';
        this.loadTranslations();
    }
    
    async loadTranslations() {
        try {
            const response = await api.fetchApi("/i18n");
            const data = await response.json();
            this.translations = data;
        } catch (error) {
            console.error("Failed to load translations:", error);
        }
    }
    
    setLanguage(language) {
        this.currentLanguage = language;
        this.updateUI();
    }
    
    translate(key, language = null) {
        const lang = language || this.currentLanguage;
        const keys = key.split('.');
        let value = this.translations[lang];
        
        for (const k of keys) {
            if (value && typeof value === 'object') {
                value = value[k];
            } else {
                return key;
            }
        }
        
        return typeof value === 'string' ? value : key;
    }
    
    updateUI() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = this.translate(key);
        });
        
        document.querySelectorAll('[data-i18n-tooltip]').forEach(element => {
            const key = element.getAttribute('data-i18n-tooltip');
            element.title = this.translate(key);
        });
    }
}

const i18n = new LocalizationManager();

app.registerExtension({
    name: "Localization",
    setup() {
        window.i18n = i18n;
    },
    
    beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeData.display_name) {
            const localizedTitle = i18n.translate(`nodes.${nodeData.name}.title`);
            if (localizedTitle !== `nodes.${nodeData.name}.title`) {
                nodeData.display_name = localizedTitle;
            }
        }
        
        if (nodeData.input && nodeData.input.required) {
            Object.keys(nodeData.input.required).forEach(inputName => {
                const localizedName = i18n.translate(`nodes.${nodeData.name}.inputs.${inputName}`);
                if (localizedName !== `nodes.${nodeData.name}.inputs.${inputName}`) {
                    const inputConfig = nodeData.input.required[inputName];
                    if (Array.isArray(inputConfig) && inputConfig.length > 1 && typeof inputConfig[1] === 'object') {
                        inputConfig[1].display_name = localizedName;
                    }
                }
            });
        }
    }
});
```

## Advanced Localization Features

### Dynamic Language Switching

```javascript
class ComfyI18n {
    constructor() {
        this.currentLanguage = this.detectLanguage();
        this.translations = {};
        this.fallbackLanguage = 'en';
        this.loadTranslations();
    }
    
    detectLanguage() {
        const browserLang = navigator.language.split('-')[0];
        const supportedLanguages = ['en', 'zh', 'ja', 'fr', 'de', 'es', 'ru', 'ko'];
        
        if (supportedLanguages.includes(browserLang)) {
            return browserLang;
        }
        
        return 'en';
    }
    
    async loadTranslations() {
        try {
            const response = await api.fetchApi("/i18n");
            const data = await response.json();
            this.translations = data;
            this.updateAllUI();
        } catch (error) {
            console.error("Failed to load translations:", error);
        }
    }
    
    setLanguage(language) {
        if (this.currentLanguage !== language) {
            this.currentLanguage = language;
            this.updateAllUI();
            this.saveLanguagePreference(language);
        }
    }
    
    saveLanguagePreference(language) {
        localStorage.setItem('comfyui_language', language);
    }
    
    translate(key, params = {}) {
        const translation = this.getTranslation(key, this.currentLanguage) || 
                          this.getTranslation(key, this.fallbackLanguage) || 
                          key;
        
        return this.interpolate(translation, params);
    }
    
    getTranslation(key, language) {
        const keys = key.split('.');
        let value = this.translations[language];
        
        for (const k of keys) {
            if (value && typeof value === 'object') {
                value = value[k];
            } else {
                return null;
            }
        }
        
        return typeof value === 'string' ? value : null;
    }
    
    interpolate(template, params) {
        return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            return params[key] !== undefined ? params[key] : match;
        });
    }
    
    formatNumber(number, options = {}) {
        return new Intl.NumberFormat(this.currentLanguage, options).format(number);
    }
    
    formatDate(date, options = {}) {
        return new Intl.DateTimeFormat(this.currentLanguage, options).format(date);
    }
    
    updateAllUI() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            const params = this.parseDataParams(element);
            element.textContent = this.translate(key, params);
        });
        
        document.querySelectorAll('[data-i18n-tooltip]').forEach(element => {
            const key = element.getAttribute('data-i18n-tooltip');
            const params = this.parseDataParams(element);
            element.title = this.translate(key, params);
        });
        
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
            const key = element.getAttribute('data-i18n-placeholder');
            const params = this.parseDataParams(element);
            element.placeholder = this.translate(key, params);
        });
        
        window.dispatchEvent(new CustomEvent('languageChanged', {
            detail: { language: this.currentLanguage }
        }));
    }
    
    parseDataParams(element) {
        const paramsAttr = element.getAttribute('data-i18n-params');
        if (!paramsAttr) return {};
        
        try {
            return JSON.parse(paramsAttr);
        } catch (error) {
            console.warn("Invalid i18n params:", paramsAttr);
            return {};
        }
    }
}

const comfyI18n = new ComfyI18n();
window.comfyI18n = comfyI18n;
```

## Best Practices

### Translation File Organization

1. **Hierarchical Structure**: Organize translations in a logical hierarchy
2. **Consistent Naming**: Use consistent naming conventions across languages
3. **Context Information**: Include context comments for translators
4. **Pluralization**: Handle plural forms appropriately for each language

```json
{
  "nodes": {
    "ImageProcessor": {
      "title": "Image Processor",
      "description": "Advanced image processing with multiple filters",
      "inputs": {
        "image": "Input Image",
        "filter": "Filter Type",
        "strength": "Filter Strength"
      },
      "outputs": {
        "result": "Processed Image"
      },
      "messages": {
        "processing": "Processing image...",
        "complete": "Processing complete",
        "error": "Processing failed: {{error}}"
      }
    }
  },
  "ui": {
    "buttons": {
      "apply": "Apply",
      "reset": "Reset",
      "cancel": "Cancel"
    },
    "status": {
      "ready": "Ready",
      "working": "Working...",
      "error": "Error"
    }
  }
}
```

### Testing Localization

```javascript
function testTranslations() {
    const testKeys = [
        'nodes.MyNode.title',
        'ui.buttons.apply',
        'messages.error'
    ];
    
    const languages = ['en', 'zh', 'ja', 'fr'];
    
    languages.forEach(lang => {
        console.log(`Testing language: ${lang}`);
        testKeys.forEach(key => {
            const translation = comfyI18n.translate(key);
            if (translation === key) {
                console.warn(`Missing translation for ${key} in ${lang}`);
            }
        });
    });
}

function testInterpolation() {
    const template = comfyI18n.translate('messages.processing_count', {
        count: 5,
        total: 10
    });
    console.log('Interpolation test:', template);
}
```

### Performance Considerations

1. **Lazy Loading**: Load translations only when needed
2. **Caching**: Cache translated strings to avoid repeated lookups
3. **Fallback Strategy**: Always provide fallback to prevent UI breakage
4. **Bundle Size**: Consider translation bundle size for web deployment

```javascript
class OptimizedI18n {
    constructor() {
        this.cache = new Map();
        this.loadedLanguages = new Set();
    }
    
    async loadLanguage(language) {
        if (this.loadedLanguages.has(language)) {
            return;
        }
        
        try {
            const response = await fetch(`/i18n/${language}.json`);
            const translations = await response.json();
            this.translations[language] = translations;
            this.loadedLanguages.add(language);
        } catch (error) {
            console.error(`Failed to load language ${language}:`, error);
        }
    }
    
    translate(key, language = this.currentLanguage) {
        const cacheKey = `${language}:${key}`;
        
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        const translation = this.getTranslation(key, language);
        this.cache.set(cacheKey, translation);
        
        return translation;
    }
}
```

## Integration with ComfyUI Core

The localization system integrates seamlessly with ComfyUI's existing infrastructure:

1. **Server Integration**: Translations are served via the `/i18n` endpoint
2. **Frontend Integration**: JavaScript extensions can access translations via the API
3. **Node Registration**: Localized node information is applied during registration
4. **UI Updates**: Language changes trigger UI updates across all components

This comprehensive localization system ensures that custom nodes can provide a native experience for users regardless of their preferred language.
