---
title: "Node Widget Customization"
---

Widgets are the interactive controls within ComfyUI nodes that allow users to input values, select options, or adjust parameters. This guide explains how to create and customize widgets for your custom nodes.

## Widget Basics

Widgets are defined in the `ComfyNode.prototype.addWidget` method. When creating custom nodes, you can define widgets that will be rendered inside your node.

Common widget types include:
- Text inputs
- Number inputs
- Sliders
- Combo boxes (dropdowns)
- Checkboxes
- Buttons

## Creating Custom Widgets

Widgets can be added to your custom node using the `addWidget` method:

```javascript
app.registerExtension({
  name: "WidgetExampleExtension",
  async beforeRegisterNodeDef(nodeType, nodeData) {
    if (nodeType.comfyClass === "MyCustomNode") {
      const onNodeCreated = nodeType.prototype.onNodeCreated;
      
      // Override the onNodeCreated method to add custom widgets
      nodeType.prototype.onNodeCreated = function() {
        const result = onNodeCreated?.apply(this, arguments);
        
        // Add a text widget
        this.addWidget("text", "Text Input", "default value", (value) => {
          console.log("Text changed:", value);
          // Update node internal state or trigger calculations
        });
        
        // Add a slider widget
        this.addWidget("slider", "Slider Value", 50, (value) => {
          console.log("Slider changed:", value);
        }, { min: 0, max: 100 });
        
        // Add a combo widget (dropdown)
        this.addWidget("combo", "Selection", "option1", (value) => {
          console.log("Selection changed:", value);
        }, { values: ["option1", "option2", "option3"] });
        
        // Add a boolean widget (checkbox)
        this.addWidget("boolean", "Enable Feature", true, (value) => {
          console.log("Checkbox changed:", value);
        });
        
        // Add a button widget
        this.addWidget("button", "Click Me", null, (value) => {
          console.log("Button clicked");
        });
        
        return result;
      };
    }
  }
});
```

## Widget Options

### Text Widget

```javascript
this.addWidget("text", "Label", "default value", callback, options);

// Options object can include:
{
  multiline: true,          // Enable multiline text input
  placeholder: "Enter text" // Placeholder text when empty
}
```

### Number Widget

```javascript
this.addWidget("number", "Label", 42, callback, options);

// Options object can include:
{
  min: 0,       // Minimum value
  max: 100,     // Maximum value
  step: 0.1,    // Increment step
  precision: 2  // Decimal precision
}
```

### Slider Widget

```javascript
this.addWidget("slider", "Label", 50, callback, options);

// Options object can include:
{
  min: 0,       // Minimum value
  max: 100,     // Maximum value
  step: 1       // Increment step
}
```

### Combo Widget (Dropdown)

```javascript
this.addWidget("combo", "Label", "default", callback, options);

// Options object can include:
{
  values: ["option1", "option2", "option3"],  // Array of options
  // Or an object with display names:
  values: {
    "Display Name 1": "value1",
    "Display Name 2": "value2"
  }
}
```

### Boolean Widget (Checkbox)

```javascript
this.addWidget("boolean", "Label", true, callback);
```

### Button Widget

```javascript
this.addWidget("button", "Label", null, callback);
```

## Custom Widget Rendering

For more advanced widget customization, you can override the `drawWidgets` method:

```javascript
app.registerExtension({
  name: "CustomRenderingExample",
  async beforeRegisterNodeDef(nodeType, nodeData) {
    if (nodeType.comfyClass === "MyCustomNode") {
      const drawWidgets = nodeType.prototype.drawWidgets;
      
      nodeType.prototype.drawWidgets = function(ctx, widget_id) {
        // If it's our custom widget, do custom rendering
        if (this.widgets && this.widgets[widget_id]?.name === "MyCustomWidget") {
          // Custom rendering code
          const w = this.widgets[widget_id];
          const [x, y] = w.last_pos;
          
          // Draw custom widget
          ctx.fillStyle = "#555";
          ctx.fillRect(x, y, 100, 20);
          
          ctx.fillStyle = "#fff";
          ctx.font = "12px Arial";
          ctx.fillText(w.value, x + 5, y + 15);
          
          return;
        }
        
        // Fall back to default rendering for other widgets
        if (drawWidgets) {
          drawWidgets.apply(this, arguments);
        }
      };
    }
  }
});
```

## Widget Value Connections

Widgets can receive values from other nodes through connections. To enable this, you need to register your widget as a connectable input:

```javascript
app.registerExtension({
  name: "ConnectableWidgetExample",
  async beforeRegisterNodeDef(nodeType, nodeData) {
    if (nodeType.comfyClass === "MyCustomNode") {
      const onNodeCreated = nodeType.prototype.onNodeCreated;
      
      nodeType.prototype.onNodeCreated = function() {
        const result = onNodeCreated?.apply(this, arguments);
        
        // Add a widget
        this.addWidget("number", "Value", 50, (value) => {
          console.log("Value changed:", value);
        });
        
        // Make the widget connectable
        const widget = this.widgets[this.widgets.length - 1];
        widget.name = "value"; // Important: this name will be used for the input
        
        // Add an input for the widget
        this.addInput("value", "number");
        
        return result;
      };
      
      // Handle connections to the widget
      const onConnectionsChange = nodeType.prototype.onConnectionsChange;
      nodeType.prototype.onConnectionsChange = function(side, slot, connect, link_info, output) {
        if (onConnectionsChange) {
          onConnectionsChange.apply(this, arguments);
        }
        
        // If an input is connected/disconnected, update widget behavior
        if (side === LiteGraph.INPUT) {
          const widgetName = this.inputs[slot].name;
          const widget = this.widgets.find(w => w.name === widgetName);
          
          if (widget) {
            // If connected, disable the widget
            if (connect) {
              widget.disabled = true;
            } else {
              widget.disabled = false;
            }
          }
        }
      };
    }
  }
});
```

## Best Practices for Widgets

1. **Use Clear Labels**: Make widget labels descriptive so users understand their purpose.

2. **Provide Sensible Defaults**: Initialize widgets with reasonable default values.

3. **Include Min/Max Values**: For numerical inputs, provide appropriate ranges.

4. **Use Appropriate Widget Types**: Choose the most suitable widget for each parameter.

5. **Handle Value Changes**: Respond appropriately to widget value changes, updating node state.

6. **Support Keyboard Accessibility**: Ensure widgets can be controlled via keyboard.

7. **Allow Connections**: When appropriate, make widgets connectable as inputs.

8. **Validate Widget Values**: Check that widget values are valid before using them.

By following these guidelines and using the widget system effectively, you can create nodes with intuitive, interactive controls that enhance the user experience.

## Related Documentation

- [JavaScript Overview](/custom-nodes/js/javascript_overview)
- [JavaScript Hooks](/custom-nodes/js/javascript_hooks)
- [Application Architecture](/custom-nodes/js/javascript_application_architecture)
- [Extension Debugging and Performance](/custom-nodes/js/javascript_debugging)